#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <thread>
#include <mutex>
#include <queue>
#include <chrono>
#include <fstream>
#include <sstream>
#include <regex>
#include <random>
#include <curl/curl.h>
#include <json/json.h>

#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#endif

class GiganticWitServer {
private:
    struct VideoRequest {
        std::string id;
        std::string topic;
        int duration;
        std::string style;
        std::string voiceType;
        std::string customPrompt;
        std::string status;
        std::string result_url;
        std::chrono::system_clock::time_point created_at;
        int progress_percentage;
        std::string current_step;
    };

    struct APIConfig {
        std::string openai_api_key;
        std::string pixabay_api_key;
        std::string cloudinary_cloud_name;
        std::string cloudinary_api_key;
        std::string creatomate_api_key;
    } config;

    std::map<std::string, VideoRequest> activeRequests;
    std::mutex requestsMutex;
    std::queue<std::string> processingQueue;
    std::mutex queueMutex;
    bool serverRunning;
    int serverPort;

public:
    GiganticWitServer(int port = 8080) : serverRunning(false), serverPort(port) {
        loadConfiguration();
        curl_global_init(CURL_GLOBAL_DEFAULT);
        startProcessingThread();
    }

    ~GiganticWitServer() {
        serverRunning = false;
        curl_global_cleanup();
    }

    void loadConfiguration() {
        // Load API keys from environment variables
        config.openai_api_key = getenv("OPENAI_API_KEY") ? getenv("OPENAI_API_KEY") : "demo-key";
        config.pixabay_api_key = getenv("PIXABAY_API_KEY") ? getenv("PIXABAY_API_KEY") : "demo-key";
        config.cloudinary_cloud_name = getenv("CLOUDINARY_CLOUD_NAME") ? getenv("CLOUDINARY_CLOUD_NAME") : "demo";
        config.cloudinary_api_key = getenv("CLOUDINARY_API_KEY") ? getenv("CLOUDINARY_API_KEY") : "demo-key";
        config.creatomate_api_key = getenv("CREATOMATE_API_KEY") ? getenv("CREATOMATE_API_KEY") : "demo-key";
    }

    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* data) {
        data->append((char*)contents, size * nmemb);
        return size * nmemb;
    }

    std::string generateRequestId() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(1000, 9999);
        
        std::stringstream ss;
        ss << "vid_" << time_t << "_" << dis(gen);
        return ss.str();
    }

    // Simulate API calls with realistic responses
    std::string generateScript(const std::string& topic, const std::string& style, int duration) {
        // Simulate OpenAI API call
        std::this_thread::sleep_for(std::chrono::seconds(2));
        
        Json::Value response;
        response["script"] = "Professional script for " + topic + " in " + style + " style, " + std::to_string(duration) + " seconds long.";
        response["scenes"][0]["narration"] = "Welcome to our comprehensive guide on " + topic;
        response["scenes"][0]["visuals"] = "Opening title sequence with modern graphics";
        response["scenes"][1]["narration"] = "Let's explore the key aspects and benefits";
        response["scenes"][1]["visuals"] = "Relevant stock footage and custom illustrations";
        
        Json::StreamWriterBuilder builder;
        return Json::writeString(builder, response);
    }

    std::string generateVoiceover(const std::string& text, const std::string& voice_type) {
        // Simulate TTS API call
        std::this_thread::sleep_for(std::chrono::seconds(3));
        return "https://demo-audio-url.com/voiceover_" + voice_type + ".mp3";
    }

    std::vector<std::string> getStockMedia(const std::string& keywords) {
        // Simulate stock media API call
        std::this_thread::sleep_for(std::chrono::seconds(2));
        return {
            "https://demo-media.com/video1.mp4",
            "https://demo-media.com/image1.jpg",
            "https://demo-media.com/video2.mp4"
        };
    }

    std::string generateCustomImage(const std::string& prompt) {
        // Simulate DALL-E API call
        std::this_thread::sleep_for(std::chrono::seconds(4));
        return "https://demo-dalle.com/custom_" + std::to_string(rand() % 1000) + ".jpg";
    }

    void updateRequestProgress(const std::string& request_id, const std::string& step, int percentage) {
        std::lock_guard<std::mutex> lock(requestsMutex);
        if (activeRequests.find(request_id) != activeRequests.end()) {
            activeRequests[request_id].current_step = step;
            activeRequests[request_id].progress_percentage = percentage;
        }
    }

    void processVideoRequest(const std::string& request_id) {
        try {
            // Step 1: Generate Script (20%)
            updateRequestProgress(request_id, "generating_script", 20);
            std::cout << "Generating script for request: " << request_id << std::endl;
            
            {
                std::lock_guard<std::mutex> lock(requestsMutex);
                auto& request = activeRequests[request_id];
                std::string script = generateScript(request.topic, request.style, request.duration);
            }
            
            // Step 2: Collect Assets (40%)
            updateRequestProgress(request_id, "collecting_assets", 40);
            std::cout << "Collecting media assets..." << std::endl;
            
            {
                std::lock_guard<std::mutex> lock(requestsMutex);
                auto& request = activeRequests[request_id];
                std::vector<std::string> media = getStockMedia(request.topic);
                std::string custom_image = generateCustomImage("Professional " + request.style + " for " + request.topic);
            }
            
            // Step 3: Generate Voice (60%)
            updateRequestProgress(request_id, "generating_voice", 60);
            std::cout << "Generating voiceover..." << std::endl;
            
            {
                std::lock_guard<std::mutex> lock(requestsMutex);
                auto& request = activeRequests[request_id];
                std::string voice_url = generateVoiceover("Narration for " + request.topic, request.voiceType);
            }
            
            // Step 4: Upload Assets (80%)
            updateRequestProgress(request_id, "uploading_assets", 80);
            std::cout << "Uploading to cloud storage..." << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(2));
            
            // Step 5: Render Video (100%)
            updateRequestProgress(request_id, "rendering_video", 90);
            std::cout << "Rendering final video..." << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(5));
            
            // Complete
            {
                std::lock_guard<std::mutex> lock(requestsMutex);
                auto& request = activeRequests[request_id];
                request.status = "completed";
                request.progress_percentage = 100;
                request.current_step = "completed";
                request.result_url = "https://demo-videos.com/" + request_id + ".mp4";
            }
            
            std::cout << "Video generation completed: " << request_id << std::endl;
            
        } catch (const std::exception& e) {
            std::lock_guard<std::mutex> lock(requestsMutex);
            auto& request = activeRequests[request_id];
            request.status = "error";
            request.current_step = "error";
            std::cerr << "Error processing request " << request_id << ": " << e.what() << std::endl;
        }
    }

    void startProcessingThread() {
        std::thread([this]() {
            while (true) {
                std::string request_id;
                
                {
                    std::lock_guard<std::mutex> lock(queueMutex);
                    if (!processingQueue.empty()) {
                        request_id = processingQueue.front();
                        processingQueue.pop();
                    }
                }
                
                if (!request_id.empty()) {
                    processVideoRequest(request_id);
                } else {
                    std::this_thread::sleep_for(std::chrono::seconds(1));
                }
            }
        }).detach();
    }

    std::string createVideoRequest(const Json::Value& request_data) {
        std::string request_id = generateRequestId();
        
        VideoRequest request;
        request.id = request_id;
        request.topic = request_data["topic"].asString();
        request.duration = request_data["duration"].asInt();
        request.style = request_data["style"].asString();
        request.voiceType = request_data["voiceType"].asString();
        request.customPrompt = request_data.get("customPrompt", "").asString();
        request.status = "queued";
        request.progress_percentage = 0;
        request.current_step = "queued";
        request.created_at = std::chrono::system_clock::now();
        
        {
            std::lock_guard<std::mutex> lock(requestsMutex);
            activeRequests[request_id] = request;
        }
        
        {
            std::lock_guard<std::mutex> lock(queueMutex);
            processingQueue.push(request_id);
        }
        
        Json::Value response;
        response["request_id"] = request_id;
        response["status"] = "queued";
        response["message"] = "Video generation request queued successfully";
        
        Json::StreamWriterBuilder builder;
        return Json::writeString(builder, response);
    }

    std::string getRequestStatus(const std::string& request_id) {
        std::lock_guard<std::mutex> lock(requestsMutex);
        
        if (activeRequests.find(request_id) == activeRequests.end()) {
            Json::Value response;
            response["error"] = "Request not found";
            Json::StreamWriterBuilder builder;
            return Json::writeString(builder, response);
        }
        
        const auto& request = activeRequests[request_id];
        Json::Value response;
        response["request_id"] = request_id;
        response["status"] = request.status;
        response["current_step"] = request.current_step;
        response["progress_percentage"] = request.progress_percentage;
        response["topic"] = request.topic;
        
        if (request.status == "completed") {
            response["result_url"] = request.result_url;
        }
        
        Json::StreamWriterBuilder builder;
        return Json::writeString(builder, response);
    }

    std::string getHTMLContent() {
        return R"(<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gigantic Wit - AI Video Generation Platform</title>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            --secondary-gradient: linear-gradient(45deg, #ff6b6b, #4ecdc4);
            --accent-color: #667eea;
            --text-dark: #333;
            --text-light: #6c757d;
            --bg-light: #f8f9fa;
            --border-light: #e9ecef;
            --success-color: #28a745;
            --warning-color: #ffc107;
            --danger-color: #dc3545;
            --shadow-light: 0 5px 15px rgba(0, 0, 0, 0.1);
            --shadow-heavy: 0 20px 60px rgba(0, 0, 0, 0.1);
            --border-radius: 15px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            line-height: 1.6;
            color: var(--text-dark);
            background: var(--primary-gradient);
            min-height: 100vh;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header */
        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            transition: var(--transition);
        }

        .nav {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 0;
        }

        .logo {
            font-size: 2.2rem;
            font-weight: 800;
            color: white;
            text-decoration: none;
            background: var(--secondary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            color: white;
            font-size: 0.9rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #28a745;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Hero Section */
        .hero {
            padding: 120px 0 80px;
            text-align: center;
            color: white;
            position: relative;
            overflow: hidden;
        }

        .hero h1 {
            font-size: clamp(2.5rem, 5vw, 4rem);
            font-weight: 900;
            margin-bottom: 1.5rem;
            background: linear-gradient(45deg, #fff, #f0f0f0, #fff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .hero p {
            font-size: 1.3rem;
            margin-bottom: 3rem;
            opacity: 0.9;
            max-width: 700px;
            margin-left: auto;
            margin-right: auto;
        }

        .cta-button {
            background: var(--secondary-gradient);
            color: white;
            padding: 1.2rem 2.5rem;
            border: none;
            border-radius: 50px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            transition: var(--transition);
        }

        .cta-button:hover {
            transform: translateY(-3px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.4);
        }

        /* Main Content */
        .main-content {
            background: white;
            border-radius: 25px;
            margin: -40px auto 60px;
            box-shadow: var(--shadow-heavy);
            overflow: hidden;
            position: relative;
        }

        .main-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: var(--secondary-gradient);
        }

        .content-wrapper {
            padding: 3rem;
        }

        /* Form Styling */
        .video-form {
            max-width: 800px;
            margin: 0 auto;
        }

        .form-row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin-bottom: 2rem;
        }

        .form-group {
            margin-bottom: 2rem;
        }

        .form-group.full-width {
            grid-column: 1 / -1;
        }

        .form-label {
            display: block;
            margin-bottom: 0.8rem;
            font-weight: 600;
            color: var(--text-dark);
            font-size: 1rem;
        }

        .form-input {
            width: 100%;
            padding: 1.2rem 1.5rem;
            border: 2px solid var(--border-light);
            border-radius: var(--border-radius);
            font-size: 1rem;
            font-family: inherit;
            transition: var(--transition);
            background: white;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--accent-color);
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
            transform: translateY(-1px);
        }

        .form-textarea {
            height: 120px;
            resize: vertical;
        }

        /* Progress Section */
        .progress-container {
            margin: 3rem 0;
            padding: 2rem;
            background: var(--bg-light);
            border-radius: var(--border-radius);
            display: none;
        }

        .progress-container.active {
            display: block;
        }

        .progress-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .progress-header h3 {
            color: var(--accent-color);
            margin-bottom: 0.5rem;
        }

        .progress-steps {
            display: flex;
            justify-content: space-between;
            position: relative;
            margin: 2rem 0;
        }

        .progress-steps::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 0;
            right: 0;
            height: 3px;
            background: var(--border-light);
            z-index: 1;
            transform: translateY(-50%);
        }

        .progress-line {
            position: absolute;
            top: 50%;
            left: 0;
            height: 3px;
            background: var(--secondary-gradient);
            z-index: 2;
            transform: translateY(-50%);
            width: 0%;
            transition: width 1s ease-out;
        }

        .step {
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 3;
            background: white;
            padding: 0 1rem;
        }

        .step-circle {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--border-light);
            color: var(--text-light);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 1.2rem;
            margin-bottom: 1rem;
            transition: var(--transition);
            border: 3px solid white;
            box-shadow: var(--shadow-light);
        }

        .step.active .step-circle {
            background: var(--accent-color);
            color: white;
            animation: stepPulse 2s infinite;
        }

        .step.completed .step-circle {
            background: var(--success-color);
            color: white;
        }

        .step.completed .step-circle::before {
            content: 'âœ“';
            font-size: 1.5rem;
        }

        @keyframes stepPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(102, 126, 234, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(102, 126, 234, 0); }
        }

        .step-label {
            font-weight: 600;
            text-align: center;
            color: var(--text-light);
            0https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Gigantic Wit - AI Video Generation Platform</title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <style>
    :root {
      --primary-gradient: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      --secondary-gradient: linear-gradient(45deg, #ff6b6b, #4ecdc4);
      --accent-color: #667eea;
      --text-dark: #333;
      --text-light: #6c757d;
      --bg-light: #f8f9fa;
      --border-light: #e9ecef;
      --success-color: #28a745;
      --warning-color: #ffc107;
      --danger-color: #dc3545;
      --shadow-light: 0 5px 15px rgba(0, 0, 0, 0.1);
      --shadow-heavy: 0 20px 60px rgba(0, 0, 0, 0.1);
      --border-radius: 15px;
      --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      line-height: 1.6;
      color: var(--text-dark);
      background: var(--primary-gradient);
      min-height: 100vh;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 20px;
    }

    /* Header */
    .header {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid rgba(255, 255, 255, 0.2);
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 1000;
      transition: var(--transition);
    }

    .nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 1rem 0;
    }

    .logo {
      font-size: 2.2rem;
      font-weight: 800;
      color: white;
      text-decoration: none;
      background: var(--secondary-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .status-indicator {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      color: white;
      font-size: 0.9rem;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #28a745;
      animation: pulse 2s infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }

    /* Hero Section */
    .hero {
      padding: 120px 0 80px;
      text-align: center;
      color: white;
      position: relative;
      overflow: hidden;
    }

    .hero h1 {
      font-size: clamp(2.5rem, 5vw, 4rem);
      font-weight: 900;
      margin-bottom: 1.5rem;
      background: linear-gradient(45deg, #fff, #f0f0f0, #fff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .hero p {
      font-size: 1.3rem;
      margin-bottom: 3rem;
      opacity: 0.9;
      max-width: 700px;
      margin-left: auto;
      margin-right: auto;
    }

    .cta-button {
      background: var(--secondary-gradient);
      color: white;
      padding: 1.g++ gigantic_wit.cpp -o gigantic_wit -lcurl -ljsoncpp -pthreadg++ gigantic_wit.cpp -o gigantic_whreadhttp://localhost:8080request.customPromptrequest.voiceTyperequest.stylerequest.durationrequest.topichttps://demo-videos.com/request.idrequest.statushttps://dalle-demo.com/custom_https://media.com/image1.jpghttps://media.com/video1.mp4https://demo-voice/// gigantic_wit.cpp
#include <iostream>
#include <string>
#include <vector>
#include <map>
#include <memory>
#include <thread>
#include <mutex>
#include <queue>
#include <chrono>
#include <fstream>
#include <sstream>
#include <regex>
#include <random>
#include <curl/curl.h>
#include <json/json.h>

#ifdef _WIN32
#include <winsock2.h>
#include <ws2tcpip.h>
#pragma comment(lib, "ws2_32.lib")
#else
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <unistd.h>
#endif

class GiganticWitServer {
private:
    struct VideoRequest {
        std::string id;
        std::string topic;
        int duration;
        std::string style;
        std::string voiceType;
        std::string customPrompt;
        std::string status;
        std::string result_url;
        std::chrono::system_clock::time_point created_at;
        int progress_percentage;
        std::string current_step;
    };

    struct APIConfig {
        std::string openai_api_key;
        std::string pixabay_api_key;
        std::string cloudinary_cloud_name;
        std::string cloudinary_api_key;
        std::string creatomate_api_key;
    } config;

    std::map<std::string, VideoRequest> activeRequests;
    std::mutex requestsMutex;
    std::queue<std::string> processingQueue;
    std::mutex queueMutex;
    bool serverRunning;
    int serverPort;

public:
    GiganticWitServer(int port = 8080) : serverRunning(false), serverPort(port) {
        loadConfiguration();
        curl_global_init(CURL_GLOBAL_DEFAULT);
        startProcessingThread();
    }

    ~GiganticWitServer() {
        serverRunning = false;
        curl_global_cleanup();
    }

    void loadConfiguration() {
        config.openai_api_key = getenv("OPENAI_API_KEY") ? getenv("OPENAI_API_KEY") : "demo-key";
        config.pixabay_api_key = getenv("PIXABAY_API_KEY") ? getenv("PIXABAY_API_KEY") : "demo-key";
        config.cloudinary_cloud_name = getenv("CLOUDINARY_CLOUD_NAME") ? getenv("CLOUDINARY_CLOUD_NAME") : "demo";
        config.cloudinary_api_key = getenv("CLOUDINARY_API_KEY") ? getenv("CLOUDINARY_API_KEY") : "demo-key";
        config.creatomate_api_key = getenv("CREATOMATE_API_KEY") ? getenv("CREATOMATE_API_KEY") : "demo-key";
    }

    static size_t WriteCallback(void* contents, size_t size, size_t nmemb, std::string* data) {
        data->append((char*)contents, size * nmemb);
        return size * nmemb;
    }

    std::string generateRequestId() {
        auto now = std::chrono::system_clock::now();
        auto time_t = std::chrono::system_clock::to_time_t(now);
        std::random_device rd;
        std::mt19937 gen(rd());
        std::uniform_int_distribution<> dis(1000, 9999);

        std::stringstream ss;
        ss << "vid_" << time_t << "_" << dis(gen);
        return ss.str();
    }

    std::string generateScript(const std::string& topic, const std::string& style, int duration) {
        std::this_thread::sleep_for(std::chrono::seconds(2));
        Json::Value response;
        response["script"] = "Script for " + topic + " in " + style + " style.";
        Json::StreamWriterBuilder builder;
        return Json::writeString(builder, response);
    }

    std::string generateVoiceover(const std::string& text, const std::string& voice_type) {
        std::this_thread::sleep_for(std::chrono::seconds(3));
        return "https://demo-voice/" + voice_type + ".mp3";
    }

    std::vector<std::string> getStockMedia(const std::string& keywords) {
        std::this_thread::sleep_for(std::chrono::seconds(2));
        return { "https://media.com/video1.mp4", "https://media.com/image1.jpg" };
    }

    std::string generateCustomImage(const std::string& prompt) {
        std::this_thread::sleep_for(std::chrono::seconds(4));
        return "https://dalle-demo.com/custom_" + std::to_string(rand() % 1000) + ".jpg";
    }

    void updateRequestProgress(const std::string& request_id, const std::string& step, int percentage) {
        std::lock_guard<std::mutex> lock(requestsMutex);
        if (activeRequests.find(request_id) != activeRequests.end()) {
            activeRequests[request_id].current_step = step;
            activeRequests[request_id].progress_percentage = percentage;
        }
    }

    void processVideoRequest(const std::string& request_id) {
        try {
            updateRequestProgress(request_id, "generating_script", 20);
            std::string script = generateScript("topic", "style", 30);

            updateRequestProgress(request_id, "collecting_assets", 40);
            auto media = getStockMedia("topic");
            auto image = generateCustomImage("prompt");

            updateRequestProgress(request_id, "generating_voice", 60);
            auto voice = generateVoiceover("text", "voiceType");

            updateRequestProgress(request_id, "uploading_assets", 80);
            std::this_thread::sleep_for(std::chrono::seconds(2));

            updateRequestProgress(request_id, "rendering_video", 90);
            std::this_thread::sleep_for(std::chrono::seconds(5));

            {
                std::lock_guard<std::mutex> lock(requestsMutex);
                auto& request = activeRequests[request_id];
                request.status = "completed";
                request.progress_percentage = 100;
                request.current_step = "completed";
                request.result_url = "https://demo-videos.com/" + request_id + ".mp4";
            }
        } catch (...) {
            std::lock_guard<std::mutex> lock(requestsMutex);
            activeRequests[request_id].status = "error";
            activeRequests[request_id].current_step = "error";
        }
    }

    void startProcessingThread() {
        std::thread([this]() {
            while (true) {
                std::string request_id;
                {
                    std::lock_guard<std::mutex> lock(queueMutex);
                    if (!processingQueue.empty()) {
                        request_id = processingQueue.front();
                        processingQueue.pop();
                    }
                }
                if (!request_id.empty()) processVideoRequest(request_id);
                else std::this_thread::sleep_for(std::chrono::seconds(1));
            }
        }).detach();
    }

    std::string createVideoRequest(const Json::Value& request_data) {
        std::string request_id = generateRequestId();
        VideoRequest request;
        request.id = request_id;
        request.topic = request_data["topic"].asString();
        request.duration = request_data["duration"].asInt();
        request.style = request_data["style"].asString();
        request.voiceType = request_data["voiceType"].asString();
        request.customPrompt = request_data.get("customPrompt", "").asString();
        request.status = "queued";
        request.progress_percentage = 0;
        request.current_step = "queued";
        request.created_at = std::chrono::system_clock::now();

        {
            std::lock_guard<std::mutex> lock(requestsMutex);
            activeRequests[request_id] = request;
        }
        {
            std::lock_guard<std::mutex> lock(queueMutex);
            processingQueue.push(request_id);
        }

        Json::Value response;
        response["request_id"] = request_id;
        response["status"] = "queued";
        response["message"] = "Video request queued";
        Json::StreamWriterBuilder builder;
        return Json::writeString(builder, response);
    }

    std::string getRequestStatus(const std::string& request_id) {
        std::lock_guard<std::mutex> lock(requestsMutex);
        if (activeRequests.find(request_id) == activeRequests.end()) {
            Json::Value res;
            res["error"] = "Request not found";
            Json::StreamWriterBuilder builder;
            return Json::writeString(builder, res);
        }
        const auto& request = activeRequests[request_id];
        Json::Value res;
        res["request_id"] = request_id;
        res["status"] = request.status;
        res["step"] = request.current_step;
        res["progress"] = request.progress_percentage;
        if (request.status == "completed") res["result_url"] = request.result_url;
        Json::StreamWriterBuilder builder;
        return Json::writeString(builder, res);
    }

    std::string getHTMLContent() {
        return R"(
<!DOCTYPE html>
<html>
<head>
<title>Gigantic Wit</title>
</head>
<body>
<h1>Gigantic Wit - AI Video Generator</h1>
<p>Submit video requests and track progress.</p>
</body>
</html>
)";
    }
};

int main() {
    GiganticWitServer server(8080);
    std::cout << "Gigantic Wit server running at http://localhost:8080" << std::endl;
    while (true) std::this_thread::sleep_for(std::chrono::seconds(10));
    return 0;
}gigantic_wit.cpp
